{
    "contents" : "# Copyright: Will Schuerman. Monday, October 27th, 2014.\n\n# File Description: Import production and identification data from compensation for coarticulation/altered auditory feedback experiment.\n\n# Packages \n\nrequire(plyr)\n\n# Read in production data \ntext.files.production <- dir(\"Production_data/\")\n\nprod.data = data.frame(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,'x', 'x')\nnames(prod.data) <- c('in.f1.25', 'in.f2.25', 'out.f1.25', 'out.f2.25', \n                      'in.f1.50', 'in.f2.50', 'out.f1.50', 'out.f2.50',\n                      'in.f1.75', 'in.f2.75', 'out.f1.75', 'out.f2.75', \n                      'block', 'trial', 'trialb', 'subj', 'session')\nfor(text.file in text.files.production){\n  tmp <- read.csv(file=paste(\"Production_data/\",\n                             text.file, sep=\"\"),\n                  header = FALSE)\n  tmp$trial = c(1:nrow(tmp))\n  tmp$trialb = rep(c(1:26), max(tmp$V13)+1)\n  tmp$subj <- substr(x = text.file,\n                     start =1,\n                     stop = regexpr(pattern = \"_\",\n                                    text.file)-1)\n  if(length(grep(\"YesPert\", text.file))>0){\n    tmp$session <- \"YesPert\"\n  }else{\n    tmp$session <- \"NoPert\"\n  }\n  names(tmp) <-c('in.f1.25', 'in.f2.25', 'out.f1.25', 'out.f2.25', \n                 'in.f1.50', 'in.f2.50', 'out.f1.50', 'out.f2.50',\n                 'in.f1.75', 'in.f2.75', 'out.f1.75', 'out.f2.75', \n                 'block', 'trial', 'trialb', 'subj', 'session')\n  prod.data <- rbind(prod.data, tmp)\n}\nprod.data = prod.data[-1,]\n\n# Increase raw block count to align with experiment procedure\nprod.data$block = prod.data$block+1\n\n# get rid of NaN trials\nprod.data <- prod.data[complete.cases(prod.data),]\n\n# get rid of 'S' in subject\nprod.data$subj <- substr(prod.data$subj, start=2, stop=3)\nprod.data$subj <- factor(prod.data$subj)\n\n# Convert to factors \nprod.data$subj <- factor(prod.data$subj)\nprod.data$session <- factor(prod.data$session)\n\n# restrict data to measurements taken at vowel midpoint.\nprod.data <- prod.data[,c(\"subj\", \"session\", \"block\",\"trialb\",\"trial\",\"in.f1.50\",\"out.f1.50\",\"in.f2.50\",\"out.f2.50\")]\n\n# remove outliers, by scaling the the inbuffers and outbuffers, and discarding anything greater than 3 standard deviations from average\nprod.data <- ddply(prod.data,\n                   c(\"subj\", \"session\"),\n                   transform,\n                   z.in.f2.50 = scale(in.f2.50))\nprod.data <- ddply(prod.data,\n                   c(\"subj\", \"session\"),\n                   transform,\n                   z.in.f1.50 = scale(in.f1.50))\ntotal.cases <- nrow(prod.data)\nprod.data <- prod.data[which(prod.data$z.in.f1.50 < 3 &\n                               prod.data$z.in.f1.50 > -3),]\nf1.outliers <- total.cases - nrow(prod.data)\nprod.data <- prod.data[which(prod.data$z.in.f2.50 < 3 &\n                               prod.data$z.in.f2.50 > -3),]\nf2.outliers <- total.cases-f1.outliers-nrow(prod.data)\n\n# calculate dispersion between first and second resonant frequencies\nprod.data$in.dispersion <- prod.data$in.f2.50 - prod.data$in.f1.50\nprod.data$out.dispersion <- prod.data$out.f2.50 - prod.data$out.f1.50\nprod.data <- ddply(prod.data,\n                   c(\"subj\", \"session\"),\n                   transform,\n                   z.in.dispersion = scale(in.dispersion))\n\n# calculate baselines as average F1 and F2 in the first block.\nprod.data$baseline.f1.50 <- 0\nprod.data$baseline.f2.50 <- 0\nprod.data$baseline.dispersion <- 0\nfor(session in levels(prod.data$session)){\n  for(subj in levels(prod.data$subj)){\n    prod.data$baseline.f1.50[which(prod.data$session==session & prod.data$subj==subj)] <- mean(prod.data[which(prod.data$session==session & prod.data$subj==subj),'in.f1.50'][which(prod.data$block==1)], na.rm=T)\n    prod.data$baseline.f2.50[which(prod.data$session==session & prod.data$subj==subj)] <- mean(prod.data[which(prod.data$session==session & prod.data$subj==subj),'in.f2.50'][which(prod.data$block==1)], na.rm=T)\n    prod.data$baseline.dispersion[which(prod.data$session==session & prod.data$subj==subj)] <- mean(prod.data[which(prod.data$session==session & prod.data$subj==subj),'in.dispersion'][which(prod.data$block==1)], na.rm=T)\n  }\n}\n\n# Read in identification data\ntext.files.identification <- dir(\"Identification_data/\")\n\nident.data = data.frame(1,1,1,1,1,'NoPert')\nnames(ident.data) <- c(\"subj\", \"trial\", \"stimulus\" , \"response\", \"block\", \"session\")\nfor(text_file in text.files.identification){\n  tmp <- read.table(file=paste(\"Identification_data/\",\n                               text_file,\n                               sep=\"\"),\n                    header = T)\n  if(length(grep(\"YESPERT\", text_file))>0){\n    tmp$session <- \"YesPert\"\n  }else{\n    tmp$session <- \"NoPert\"\n  }\n  ident.data <- rbind(ident.data, tmp)\n}\nident.data = ident.data[-1,]\n\n# move block down by one, so that block 0 is the pre-test\nident.data$block <- ident.data$block-1\n\n# Convert to factors \nident.data$subj <- factor(ident.data$subj)\nident.data$trial <- factor(ident.data$trial)\nident.data$session <- factor(ident.data$session)\nident.data$block <- factor(ident.data$block)\n\n# fix times when participants definitely hit the wrong button \nident.data$response[which(ident.data$response==2 & ident.data$stimulus == 0)] <- 1\nident.data$response[which(ident.data$response==1 & ident.data$stimulus == 100)] <- 2\n\n# fix times when participants hit the number 3\nident.data$response[which(ident.data$response==3)] <- 2\n\n# subtract 1 from the responses to make it 0 and 1\nident.data$response <- ident.data$response -1\n\n# keep a record of old stimulus values\nident.data$old.stimulus <- ident.data$stimulus\n\n# change all \"100\" stimuli to 2 more than participant's maximum\nmax_stimuli <- with(ident.data[which(ident.data$stimulus!=100),],\n                    tapply(stimulus, subj, max))\nmax_stimuli <- data.frame(max_stimuli)\nmax_stimuli$subj <- row.names(max_stimuli)\n\nfor(subj in unique(ident.data$subj)){\n  ident.data$stimulus[which(ident.data$stimulus==100 & ident.data$subj==subj)] <- max_stimuli$max_stimuli[which(max_stimuli$subj==subj)] + 2\n}\n\n# change all \"0\" stimuli to 2 less than participant's minimum\nmin_stimuli <- with(ident.data[which(ident.data$stimulus!=0),],\n                    tapply(stimulus, subj, min))\nmin_stimuli <- data.frame(min_stimuli)\nmin_stimuli$subj <- row.names(min_stimuli)\n\nfor(subj in unique(ident.data$subj)){\n    ident.data$stimulus[which(ident.data$stimulus==0 & ident.data$subj==subj)] <- min_stimuli$min_stimuli[which(min_stimuli$subj==subj)] - 2\n}\n\n# summarise ident.data for use with plotting function\nident.summarized.data <- ddply(ident.data, c(\"subj\", \"block\", \"session\"), summarise, mean(response))\n\n# rename variable.\nnames(ident.summarized.data) <- c(\"subj\", \"block\", \"session\", \"proportion\")",
    "created" : 1419379352860.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3779074734",
    "id" : "A784D31A",
    "lastKnownWriteTime" : 1419441296,
    "path" : "~/Documents/Git/sample_expr/import_and_clean_raw_data.R",
    "project_path" : "import_and_clean_raw_data.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}